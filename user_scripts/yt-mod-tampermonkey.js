// ==UserScript==
// @name         ABK's YT-Mod
// @namespace    https://github.com/BluABK/yt-mod
// @version      0.5
// @description  Enhance your YouTube experience.
// @author       BluABK
// @match        https://www.youtube.com/feed/subscriptions*
// @match        https://www.youtube.com/c/*/videos
// @grant        none
// @require      http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js
// @require      https://gist.github.com/raw/2625891/waitForKeyElements.js
// ==/UserScript==

(function() {
    'use strict';

    // Constants / Common properties.
    // Browser:
    const LOCAL_STORAGE_MAX_SIZE = 10485762; // NB: Generated by getStorageTotalSize, your results may vary!
    // Tags:
    const GRID_RENDERER = "YTD-GRID-RENDERER";
    const VIDEO_TILE_TAG_NAME = "YTD-GRID-VIDEO-RENDERER";
    const VIDEO_TILE_THUMBNAIL_TAG_NAME = "YTD-THUMBNAIL";
    // Local Storage keys:
    const YTMOD_MODIFIED_VIDEOS_KEY = "yt-mod-modified-videos";

    // Helpers
    const COLORS =
        ['#80ED12', '#A5D604', '#C7B601', '#E39209', '#F66C1C', '#FE4838', '#FB295B', '#ED1180',
        '#D504A6', '#B601C8', '#910AE3', '#6B1DF6', '#4739FE', '#285BFB', '#1181ED', '#03A6D5',
        '#01C8B5', '#0AE491', '#1DF66B', '#3AFE47', '#5CFB28', '#82EC10', '#A7D403', '#C9B401',
        '#E4900A', '#F76A1E', '#FE463A', '#FB275D', '#EC1082', '#D403A8', '#B401CA', '#8F0AE5',
        '#691EF7', '#453BFE', '#275DFB', '#1083EC', '#03A8D3', '#01CAB3', '#0BE58F', '#1FF769',
        '#3BFE45', '#5EFA26', '#84EB0F', '#A9D303', '#CBB301', '#E68E0B', '#F7681F', '#FE443C',
        '#FA265F', '#EB0F84']; // 50 total

    /**
     * CONFIG
     */
    const CONFIG = {
        localStorageUsageLimit: LOCAL_STORAGE_MAX_SIZE - 1024,
        dimClickedVideos: true,
        dimmedVideoOpacity: 0.25,
        customProto: "GimmeYT",
        customProtoHrefOnVideoThumbnail: true,
        customProtoHrefOnVideoTitle: false,
        colouriseVideoTiles: true,
        colourisedVideoTileAlpha: 30
    };

    /**
     * Calculates the rough size of an object in bytes.
     *
     * Based on: https://stackoverflow.com/a/11900218/13519872
     *
     * NB some caveats:
     *  - Returned number will be a rought estimation, not an exact number!
     *  - This function does not count references hidden in closures.
     *    For example:
     *      ```
     *      let a = { n: 1 };
     *      let b = { a: function() { return a } };
     *      roughSizeOfObject(b);
     *      ```
     *
     *      Here b holds reference to a, but roughSizeOfObject() returns 0!
     *
     * @param object Object to get size of.
     * @returns {number} Size of object (in bytes).
     */
    function sizeOf(object) {
        if (typeof object === 'object') {
            let bytes = 0;
            let objectList = [];
            let stack = [object];

            while (stack.length) {
                let value = stack.pop();

                if (typeof value === 'boolean') {
                    bytes += 4;
                }
                else if (typeof value === 'string') {
                    // Characters in JavaScript are stored according to ECMA-262 3rd Edition Specification.
                    bytes += value.length * 2;
                }
                else if (typeof value === 'number') {
                    bytes += 8;
                }
                else if (typeof value === 'object' && objectList.indexOf(value) === -1)
                {
                    objectList.push(value);

                    for(let i in value) {
                        stack.push(value[i]);
                    }
                }
            }

            return bytes;
        } else if (typeof object === 'boolean') {
            return 4;
        }
        else if (typeof object === 'string') {
            // Characters in JavaScript are stored according to ECMA-262 3rd Edition Specification.
            return object.length * 2;
        }
        else if (typeof object === 'number') {
            return 8;
        } else {
            let msg = "Object not of type 'object', 'boolean', 'string' or 'number'!";
            console.error(msg, typeof(object), object);

            throw Error(msg);
        }

    }

    // Extend Local Storage Object functionality to support JSON as value.
    Storage.prototype.setObject = function(key, value) {
        this.setItem(key, JSON.stringify(value));
    }
    Storage.prototype.getObject = function(key) {
        let value = this.getItem(key);
        return value && JSON.parse(value);
    }

    /**
     * Calculate the max size of Local Storage for this client.
     *
     * Doubles the size until the limit is reached or the test fails.
     * It then stores half the distance between low and high and subtracts/adds
     * a half of the half each time (subtract on failure and add on success); honing into the proper value.
     *
     * It also backs up the contents before testing, then restores them.
     *
     * @param upperLimit Limit how far upwards to scan exponentially, before starting the binary search (in bytes).
     * @returns {number} Max size of Local Storage (in bytes).
     */
    function getLocalStorageMaxSize(upperLimit = 1024 * 1024 * 1024) {
        let store = localStorage, testkey = "$_test"; // (NOTE: Test key is part of the storage!!! It should also be an even number of characters)
        let backup = {};
        let low = 0;
        let high = 1;
        let _upperLimit = upperLimit / 2;
        let upperTest = true;

        let test = function (_size) {
            try {
                store.removeItem(testkey);
                store.setItem(testkey, new Array(_size + 1).join('0'));
            } catch (_ex) {
                return false;
            }
            return true;
        }

        for (let i = 0, n = store.length; i < n; ++i) {
            backup[store.key(i)] = store.getItem(store.key(i));
        }

        store.clear(); // (you could iterate over the items and backup first then restore later)

        while ((upperTest = test(high)) && high < _upperLimit) {
            low = high;
            high *= 2;
        }

        if (!upperTest) {
            let half = ~~((high - low + 1) / 2); // (~~ is a faster Math.floor())

            high -= half;

            while (half > 0) {
              high += (half = ~~(half / 2)) * (test(high) ? 1 : -1);
            }

            high = testkey.length + high;
        }

        if (high > _upperLimit) {
            high = _upperLimit;
        }

        store.removeItem(testkey);
        for (let p in backup) {
          store.setItem(p, backup[p]);
        }

        return high * 2; // (*2 because of Unicode storage)
    }

    // List to store video tiles
    let videoTiles = [];

    // Videos that have been modified in some way by this user-script.
    function getModifiedVideos() {
        //return window.localStorage.getObject(YTMOD_MODIFIED_VIDEOS_KEY);
        return [];
    }

    function setModifiedVideos(jsonObj) {
        // FIXME: Add storage usage handing, sizeOf, localStorageUsageLimit etc. Truncate old entries until below limit.
        //window.localStorage.setObject(YTMOD_MODIFIED_VIDEOS_KEY, jsonObj)
    }

    function setModifiedVideosEntry(videoId, key, value) {
        let modifiedVideos = getModifiedVideos();

        // If video is not already in list:
        if (!(videoId in modifiedVideos)) {
            // Add video entry with default properties.
            modifiedVideos[videoId] = {
                "dim": false
            };
        }

        modifiedVideos[videoId][key] = value;

        setModifiedVideos(modifiedVideos);
    }

    if (!(YTMOD_MODIFIED_VIDEOS_KEY in window.localStorage)) {
        //window.localStorage.setObject(YTMOD_MODIFIED_VIDEOS_KEY, {});
    }

    function isVideoTile(jNode) {
         return jNode.tagName === VIDEO_TILE_TAG_NAME;
    }

    /**
     * Throws exception if object's tag name is not what is expected.
     * @param obj Object to check tag name of.
     * @param tag Tag name (string) to ensure.
     */
    function ensureTagIs(obj, tag) {
        if (obj.tagName !== tag)
        {
            console.error(`Object was not of expected tag '${tag}'!`, obj)
            throw new Error(`Object was not of expected tag '${tag}'!`);
        }
    }

    /**
     * Acquire handles to stuff we want to manipulate.
     * @param eventTarget
     */
    function getTileHandles(eventTarget) {
        if (eventTarget == null) {
            console.error(`event target was null or undefined!`, eventTarget);
            throw new Error(`event target was null or undefined!`);
        }

        let videoThumbnailElement = eventTarget;
        let currentTagName = eventTarget.tagName;

        while (currentTagName !== VIDEO_TILE_THUMBNAIL_TAG_NAME) {
            // Traverse up the stack until the desired element is found.
            if (videoThumbnailElement.parentElement != null) {
                videoThumbnailElement = videoThumbnailElement.parentElement;
                currentTagName = videoThumbnailElement.tagName;
            } else {
                // In case of null we've likely traveled up the entire stack, but not found a match.
                console.error(`Video thumbnail was null or no occurrence of ${VIDEO_TILE_THUMBNAIL_TAG_NAME} found while traversing stack of event target!`, eventTarget);
                throw new Error(`Video thumbnail was null or no occurrence of ${VIDEO_TILE_THUMBNAIL_TAG_NAME} found while traversing stack of event target!`);
            }
        }

        let videoThumbnail = videoThumbnailElement.children.thumbnail;
        //console.info("videoThumbnailElement", videoThumbnailElement);
        //console.info("videoThumbnail", videoThumbnail);

        // Get the video ID.
        let videoId;
        let href = videoThumbnail.href.toString();
        //console.info("href", href);
        let reSearchVideoId = /(\?v=|shorts\/)(.*)/;
        let match = href.match(reSearchVideoId); // [1];
        //console.info("match", match);
        if (match) {
            // Unmodified YouTube URL.
            videoId = match[match.length - 1];
        } else {
            // Modified custom proto URL.
            let prefix = `${CONFIG.customProto}:`.toLowerCase();
            if (href.startsWith(prefix)) {
                videoId = href.substr(prefix.length)
                //videoId = href.match(/gimmeyt\:(.*)/)
            } else {
                let _msg = `Unhandled HREF pattern!`;
                console.error(_msg, href, videoThumbnail);
                throw Error(_msg);
            }
        }

        // A video tile has a list of dismissed and dismissible (dismissed isn't needed at this time, so skipped.).
        let videoDismissible = videoThumbnailElement.parentElement; // div id="dismissible", container element for tile content.

        // The video tile element itself.
        let videoTile = videoThumbnailElement.parentElement.parentElement; // div id="items" class="style-scope ytd-gid-renderer"

        // Other useful fields.
        let videoDetails = videoDismissible.children[1];
        let videoButtons = videoDismissible.children[2];

        let videoMeta = videoDetails.children.meta;
        let videoTitle = videoMeta.children[0].children[1];
        let videoMetadataContainer = videoMeta.children[1];
        let videoChannelNameElement = videoMetadataContainer.children.metadata.children[0].children[0];
        let videoChannelName = videoChannelNameElement.children.container.children[0].children[0].children[0];

        return {
            tile: videoTile,
            videoId: videoId,
            thumbnailElement: videoThumbnailElement,
            thumbnail: videoThumbnail,
            content: videoDismissible,
            details: videoDetails,
            buttons: videoButtons,
            meta: videoMeta,
            title: videoTitle,
            metadataContainer: videoMetadataContainer,
            channelNameElement: videoChannelNameElement,
            channelName: videoChannelName
        };
    }

    function listVideoTiles() {
        for (let i = 0; i < videoTiles.length; i++) {
            console.log(`videoTile #${i}`, videoTiles[i]);
        }
    }

    /**
     * Dims the video tile.
     * @param videoTileHandles
     * @param opacity
     */
    function dimVideoTile(videoTileHandles, opacity = 0.25) {
        // Expects tag: ytd-grid-video-renderer (HTMLElement).
        ensureTagIs(videoTileHandles.tile, VIDEO_TILE_TAG_NAME);
        videoTileHandles.tile.style.opacity = opacity.toString();
        setModifiedVideosEntry(videoTileHandles.videoId, "dim", true);
    }

    /**
     * Hides the video tile.
     * @param videoTile ytd-grid-video-renderer HTMLElement
     */
    function hideVideoTile(videoTile) {
        ensureTagIs(videoTile, VIDEO_TILE_TAG_NAME);
        videoTile.style.display = "none";
    }

    /**
     * Shows the video tile.
     * @param videoTile ytd-grid-video-renderer HTMLElement
     */
    function showVideoTile(videoTile) {
        ensureTagIs(videoTile, VIDEO_TILE_TAG_NAME);
        videoTile.style.display = "block";
    }

    /**
     *  Hide/Unhides the video tile.
     * @param videoTile ytd-grid-video-renderer HTMLElement
     */
    function toggleVisibility(videoTile) {
        ensureTagIs(videoTile, VIDEO_TILE_TAG_NAME);
        videoTile.style.display !== "none" ? videoTile.style.display = "none" : videoTile.style.display = "block";
    }

    /**
     * Removes video tile from feed (built-in).
     *
     * NB: There is no simple way to undo this,
     * it is removed from its parent using a provided built-in function.
     * @param videoTile
     */
    function removeVideoTile(videoTile) {
        ensureTagIs(videoTile, VIDEO_TILE_TAG_NAME);
        videoTile.remove();
    }

    function handleVideoThumbMouseDown(event) {
        // console.log("event", event);

        if (event.which === 2) {
            console.log(`Handling ${event.type} for video`, event, event.originalTarget);


            // Acquire handles to stuff we want to manipulate.
            let videoTileHandles = getTileHandles(event.originalTarget);

            // Make a handled video tile stand out, so it's easier to distinguish:
            if (CONFIG.dimClickedVideos) {
                // - Dim the video.
                dimVideoTile(videoTileHandles, CONFIG.dimmedVideoOpacity);
            }
         }
    }

    /**
     * Video tile handler.
     *
     * @param gridRenderer GRID_RENDERER element which holds the video tiles.
     */
    function handleVideoTiles(gridRenderer) {
        let items = gridRenderer.children.items;

        let colorCounter = 0;
        for (let videoTileElement of items.children) {
            videoTiles.push(videoTileElement);

            // Acquire handles to stuff we want to manipulate.
            // FIXME: Should probably make getTileHandles handle video tile as argument instead of needing to pass its thumbnail.
            // "Handle" issue with children not having a dismissible key.
            if (videoTileElement.children.dismissible == null) {
                console.error("videoTileElement.children.dismissible == null", videoTileElement.children);
                console.error("videoTileElement.children.dismissible == null", videoTileElement);
                continue;
            }
            let videoTileHandles = getTileHandles(videoTileElement.children.dismissible.children[0].children[0]);
            let videoId = videoTileHandles.videoId;
            //console.info("videoTileHandles", videoTileHandles);

            // Beautiful rainbow colouring (primarily for debug purposes).
            if (colorCounter > COLORS.length) {
                colorCounter = 0;
            }

            if (CONFIG.colouriseVideoTiles) videoTileElement.style.background = COLORS[colorCounter] + CONFIG.colourisedVideoTileAlpha.toString(); // color + alpha

            // NB: we cannot reliably use the click event for event handlers on the middle or right button.
            // Instead, to distinguish between the mouse buttons we have to use the mousedown and mouseup
            // events as most browsers do fire mousedown and mouseup events for any mouse button.
            videoTileHandles.thumbnail.addEventListener("mousedown", handleVideoThumbMouseDown, true);

            if (CONFIG.customProtoHrefOnVideoThumbnail || CONFIG.customProtoHrefOnVideoTitle) {
                // Redirect the <a href>.
                if (CONFIG.customProtoHrefOnVideoThumbnail) {
                    videoTileHandles.thumbnail.setAttribute('href', `${CONFIG.customProto}:${videoId}`);
                }
                if (CONFIG.customProtoHrefOnVideoTitle) {
                    videoTileHandles.title.setAttribute('href', `${CONFIG.customProto}:${videoId}`);
                }
            }
            let modifiedVideos = getModifiedVideos();

            if (videoId in getModifiedVideos()) {
                if (CONFIG.dimClickedVideos) {
                    if (modifiedVideos[videoId]["dim"]) dimVideoTile(videoTileHandles);
                }
            }

            colorCounter++;
        }
    }

    /**
     * Removes an event listener, given required criteria.
     *
     * @param target Target element to remove the listener from.
     * @param type Listener type.
     * @param listener The listener to be removed.
     */
    function removeListener(target, type, listener) {
        console.log("Removing listener", target.tagName, type, listener);
        // If null or undefined, treat as malformed.
        if (target == null) {
            console.error("removeListener target was null or undefined, aborted!", type, listener);
            return;
        }

        target.removeEventListener(type, listener);
        console.log("Removed listener", target.tagName, type, listener);
    }

    /**
     * Parse the subscription feed.
     *
     * @param jNode Object containing a context that is supposedly the grid renderer.
     *
     *              Object
     *              {
     *                  0: ytd-grid-renderer.style-scope.ytd-item-section-renderer,
     *                  context: ytd-grid-renderer.style-scope.ytd-item-section-renderer,
     *                  length: 1
     *              }
     */
    function parseSubfeed(jNode) {
        // Make sure that the context is of expected tag.
        ensureTagIs(jNode.context, GRID_RENDERER);

        // Handle video tiles.
        handleVideoTiles(jNode.context);
    }

    /**
     * ================================================================================================================
     * ===================================================== MAIN =====================================================
     * ================================================================================================================
     */

    /**
     * Wait for all video tiles to load before executing own code.
     *
     * Calls the given function with the given element id passed as argument.
     */
    waitForKeyElements('ytd-grid-renderer.style-scope', parseSubfeed);

    /**
     * YT-Mod API
     *
     * Exposes certain properties to the web browser to add some basic form of API.
     */
    // Object for own exposed API.
    let YTMod = window.YTMod = {};

    // Exposed API:
    // -- Variables.
    YTMod.CONIFG = CONFIG;
    YTMod.videoTiles = videoTiles;
    // -- Internal helpers.
    YTMod.sizeOf = sizeOf;
    YTMod.getLocalStorageMaxSize = getLocalStorageMaxSize;
    // -- Tile.
    YTMod.toggleVisibility = toggleVisibility;
    YTMod.showVideoTile = showVideoTile;
    YTMod.hideVideoTile = hideVideoTile;
    YTMod.dimVideoTile = dimVideoTile;
    YTMod.listVideoTiles = listVideoTiles;

})();
